// Generated at Fri Nov 16 19:12:39 2012. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/data1/aferapon/BH/BlackHolesAnalysis_8TeV/BlackHolesAnalysis_533_PF/CMSSW_5_3_3/src/DataFormats/TrackerCommon/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("edm") );
  ::Reflex::Type type_60 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_3093 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_3128 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_1933 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_302 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_1418 = ::Reflex::TypeBuilder(Reflex::Literal("ClusterSummary"));
  ::Reflex::Type type_2206 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_4080 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_2558 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_2560 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<double>"));
  ::Reflex::Type type_2099 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_2556 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2557 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_3977 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<ClusterSummary>"));
  ::Reflex::Type type_2317 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<ClusterSummary>"));
  ::Reflex::Type type_2561 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::vector<double> >"));
  ::Reflex::Type type_2559 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_3983 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<ClusterSummary>"));
  ::Reflex::Type type_3379 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_20788 = ::Reflex::ReferenceBuilder(type_1418);
  ::Reflex::Type type_1418c = ::Reflex::ConstBuilder(type_1418);
  ::Reflex::Type type_20789 = ::Reflex::ReferenceBuilder(type_1418c);
  ::Reflex::Type type_2100 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2099);
  ::Reflex::Type type_27153 = ::Reflex::PointerBuilder(type_1418c);
  ::Reflex::Type type_2206c = ::Reflex::ConstBuilder(type_2206);
  ::Reflex::Type type_3937 = ::Reflex::ReferenceBuilder(type_2206c);
  ::Reflex::Type type_27154 = ::Reflex::PointerBuilder(type_1418);
  ::Reflex::Type type_3983c = ::Reflex::ConstBuilder(type_3983);
  ::Reflex::Type type_27155 = ::Reflex::PointerBuilder(type_3983c);
  ::Reflex::Type type_4080c = ::Reflex::ConstBuilder(type_4080);
  ::Reflex::Type type_17750 = ::Reflex::ReferenceBuilder(type_4080c);
  ::Reflex::Type type_22713 = ::Reflex::ReferenceBuilder(type_2556);
  ::Reflex::Type type_23280 = ::Reflex::ReferenceBuilder(type_3379);
  ::Reflex::Type type_3093c = ::Reflex::ConstBuilder(type_3093);
  ::Reflex::Type type_3186 = ::Reflex::PointerBuilder(type_3093c);
  ::Reflex::Type type_7012 = ::Reflex::ReferenceBuilder(type_3186);
  ::Reflex::Type type_2557c = ::Reflex::ConstBuilder(type_2557);
  ::Reflex::Type type_22714 = ::Reflex::ReferenceBuilder(type_2557c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __ClusterSummary
#undef __ClusterSummary
#endif
class __ClusterSummary {
  public:
  __ClusterSummary();
  ::std::vector<std::basic_string<char> > userContent;
  ::std::vector<int> iterator_;
  ::std::vector<int> modules_;
  ::std::vector<std::vector<double> > genericVariables_;
  ::std::vector<std::vector<double> > genericVariablesTmp_;
};
#ifdef __edm__Wrapper_ClusterSummary_
#undef __edm__Wrapper_ClusterSummary_
#endif
class __edm__Wrapper_ClusterSummary_ {
  public:
  __edm__Wrapper_ClusterSummary_();
  bool present;
  ::ClusterSummary obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class ClusterSummary -------------------------------
static void destructor_5359(void*, void * o, const std::vector<void*>&, void *) {
(((::ClusterSummary*)o)->::ClusterSummary::~ClusterSummary)();
}
static  void operator_5360( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ClusterSummary*)o)->operator=)(*(const ::ClusterSummary*)arg[0]);
  else   (((::ClusterSummary*)o)->operator=)(*(const ::ClusterSummary*)arg[0]);
}

static void constructor_5361( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ClusterSummary(*(const ::ClusterSummary*)arg[0]);
  else ::new(mem) ::ClusterSummary(*(const ::ClusterSummary*)arg[0]);
}

static void constructor_5362( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ClusterSummary();
  else ::new(mem) ::ClusterSummary();
}

static  void method_5363( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::ClusterSummary*)o)->GetGenericVariable)(*(int*)arg[0],
    *(int*)arg[1]));
  else   (((const ::ClusterSummary*)o)->GetGenericVariable)(*(int*)arg[0],
    *(int*)arg[1]);
}

static  void method_5364( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::ClusterSummary*)o)->GetGenericVariable)(*(::std::string*)arg[0],
    *(int*)arg[1]));
  else   (((const ::ClusterSummary*)o)->GetGenericVariable)(*(::std::string*)arg[0],
    *(int*)arg[1]);
}

static  void method_5365( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<double>)((((const ::ClusterSummary*)o)->GetGenericVariable)(*(::std::string*)arg[0]));
  else   (((const ::ClusterSummary*)o)->GetGenericVariable)(*(::std::string*)arg[0]);
}

static  void method_5366( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<double>)((((const ::ClusterSummary*)o)->GetGenericVariable)(*(int*)arg[0]));
  else   (((const ::ClusterSummary*)o)->GetGenericVariable)(*(int*)arg[0]);
}

static  void method_5367( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::vector<double> >)((((const ::ClusterSummary*)o)->GetGenericVariable)());
  else   (((const ::ClusterSummary*)o)->GetGenericVariable)();
}

static  void method_5368( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ClusterSummary*)o)->SetGenericVariable)(*(int*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_5369( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ClusterSummary*)o)->SetGenericVariable)(*(::std::string*)arg[0],
    *(int*)arg[1],
    *(double*)arg[2]);
}

static  void method_5370( void*, void* o, const std::vector<void*>&, void*)
{
  (((::ClusterSummary*)o)->PrepairGenericVariable)();
}

static  void method_5371( void*, void* o, const std::vector<void*>&, void*)
{
  (((::ClusterSummary*)o)->ClearGenericVariable)();
}

static  void method_5372( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::ClusterSummary*)o)->SetUserContent)(*(::std::vector<std::basic_string<char> >*)arg[0]);
}

static  void method_5373( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((::ClusterSummary*)o)->GetUserContent)());
  else   (((::ClusterSummary*)o)->GetUserContent)();
}

static  void method_5374( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((::ClusterSummary*)o)->GetUserContentSize)());
  else   (((::ClusterSummary*)o)->GetUserContentSize)();
}

static  void method_5375( void*, void* o, const std::vector<void*>&, void*)
{
  (((const ::ClusterSummary*)o)->GetUserContentInfo)();
}

static  void method_5376( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::ClusterSummary*)o)->GetVariableLocation)(*(::std::string*)arg[0]));
  else   (((const ::ClusterSummary*)o)->GetVariableLocation)(*(::std::string*)arg[0]);
}

static  void method_5377( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ClusterSummary*)o)->SetUserModules)(*(int*)arg[0]);
}

static  void method_5378( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<int>)((((const ::ClusterSummary*)o)->GetUserModules)());
  else   (((const ::ClusterSummary*)o)->GetUserModules)();
}

static  void method_5379( void*, void* o, const std::vector<void*>&, void*)
{
  (((::ClusterSummary*)o)->ClearUserModules)();
}

static  void method_5380( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::ClusterSummary*)o)->GetModuleLocation)(*(int*)arg[0]));
  else   (((const ::ClusterSummary*)o)->GetModuleLocation)(*(int*)arg[0]);
}

static  void method_5381( void*, void* o, const std::vector<void*>&, void*)
{
  (((::ClusterSummary*)o)->SetUserIterator)();
}

static  void method_5382( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::vector<int>)((((const ::ClusterSummary*)o)->GetUserIterator)());
  else   (((const ::ClusterSummary*)o)->GetUserIterator)();
}

static  void method_5383( void*, void* o, const std::vector<void*>&, void*)
{
  (((::ClusterSummary*)o)->ClearUserIterator)();
}

static  void method_5384( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<std::basic_string<char> >)((((const ::ClusterSummary*)o)->DecodeProvInfo)(*(::std::string*)arg[0]));
  else   (((const ::ClusterSummary*)o)->DecodeProvInfo)(*(::std::string*)arg[0]);
}

static void method_newdel_1418( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::ClusterSummary >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::ClusterSummary >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::ClusterSummary >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::ClusterSummary >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::ClusterSummary >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ClusterSummary -------------------------------
void __ClusterSummary_db_datamem(Reflex::Class*);
void __ClusterSummary_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ClusterSummary_datamem_bld(&__ClusterSummary_db_datamem);
Reflex::GenreflexMemberBuilder __ClusterSummary_funcmem_bld(&__ClusterSummary_db_funcmem);
void __ClusterSummary_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ClusterSummary"), typeid(::ClusterSummary), sizeof(::ClusterSummary), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddEnum(Reflex::Literal("ClusterSummary::CMSTracker"), Reflex::Literal("TRACKER=0;TIB=1;TIB_1=11;TIB_2=12;TIB_3=13;TIB_4=14;TOB=2;TOB_1=21;TOB_2=22;TOB_3=23;TOB_4=24;TOB_5=25;TOB_6=26;TID=3;TIDM=31;TIDP=32;TIDM_1=311;TIDM_2=312;TIDM_3=313;TIDP_1=321;TIDP_2=322;TIDP_3=323;TIDMR_1=3110;TIDMR_2=3120;TIDMR_3=3130;TIDPR_1=3210;TIDPR_2=3220;TIDPR_3=3230;TEC=4;TECM=41;TECP=42;TECM_1=411;TECM_2=412;TECM_3=413;TECM_4=414;TECM_5=415;TECM_6=416;TECM_7=417;TECM_8=418;TECM_9=419;TECP_1=421;TECP_2=422;TECP_3=423;TECP_4=424;TECP_5=425;TECP_6=426;TECP_7=427;TECP_8=428;TECP_9=429;TECMR_1=4110;TECMR_2=4120;TECMR_3=4130;TECMR_4=4140;TECMR_5=4150;TECMR_6=4160;TECMR_7=4170;TECPR_1=4210;TECPR_2=4220;TECPR_3=4230;TECPR_4=4240;TECPR_5=4250;TECPR_6=4260;TECPR_7=4270;PIXEL=5;FPIX=6;FPIX_1=61;FPIX_2=62;FPIX_3=63;FPIXM=611;FPIXP=612;FPIXM_1=6110;FPIXM_2=6120;FPIXM_3=6130;FPIXP_1=6210;FPIXP_2=6220;FPIXP_3=6230;BPIX=7;BPIX_1=71;BPIX_2=72;BPIX_3=73"), &typeid(ClusterSummary::CMSTracker), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddEnum(Reflex::Literal("ClusterSummary::VariablePlacement"), Reflex::Literal("NMODULES=0;CLUSTERSIZE=1;CLUSTERCHARGE=2;NMODULESPIXELS=3;CLUSTERSIZEPIXELS=4;CLUSTERCHARGEPIXELS=5"), &typeid(ClusterSummary::VariablePlacement), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ClusterSummary"), destructor_5359, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_20788, type_20789), Reflex::Literal("operator="), operator_5360, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20789), Reflex::Literal("ClusterSummary"), constructor_5361, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ClusterSummary"), constructor_5362, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1418, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__ClusterSummary_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__ClusterSummary_funcmem_bld);
}

//------Delayed data member builder for class ClusterSummary -------------------
void __ClusterSummary_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_2559, Reflex::Literal("userContent"), OffsetOf(__shadow__::__ClusterSummary, userContent), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE)
  .AddDataMember(type_2558, Reflex::Literal("iterator_"), OffsetOf(__shadow__::__ClusterSummary, iterator_), ::Reflex::PRIVATE)
  .AddDataMember(type_2558, Reflex::Literal("modules_"), OffsetOf(__shadow__::__ClusterSummary, modules_), ::Reflex::PRIVATE)
  .AddDataMember(type_2561, Reflex::Literal("genericVariables_"), OffsetOf(__shadow__::__ClusterSummary, genericVariables_), ::Reflex::PRIVATE)
  .AddDataMember(type_2561, Reflex::Literal("genericVariablesTmp_"), OffsetOf(__shadow__::__ClusterSummary, genericVariablesTmp_), ::Reflex::PRIVATE | ::Reflex::TRANSIENT | ::Reflex::MUTABLE);
}
//------Delayed function member builder for class ClusterSummary -------------------
void __ClusterSummary_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1933, type_60, type_60), Reflex::Literal("GetGenericVariable"), method_5363, 0, "variableLocation;module", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1933, type_2100, type_60), Reflex::Literal("GetGenericVariable"), method_5364, 0, "variableName;module", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2560, type_2100), Reflex::Literal("GetGenericVariable"), method_5365, 0, "variableName", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2560, type_60), Reflex::Literal("GetGenericVariable"), method_5366, 0, "variableLocation", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2561), Reflex::Literal("GetGenericVariable"), method_5367, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093, type_60, type_60, type_1933), Reflex::Literal("SetGenericVariable"), method_5368, 0, "variableLocation;module;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093, type_2100, type_60, type_1933), Reflex::Literal("SetGenericVariable"), method_5369, 0, "variableName;module;value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093), Reflex::Literal("PrepairGenericVariable"), method_5370, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093), Reflex::Literal("ClearGenericVariable"), method_5371, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093, type_2559), Reflex::Literal("SetUserContent"), method_5372, 0, "Content", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2559), Reflex::Literal("GetUserContent"), method_5373, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60), Reflex::Literal("GetUserContentSize"), method_5374, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093), Reflex::Literal("GetUserContentInfo"), method_5375, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60, type_2100), Reflex::Literal("GetVariableLocation"), method_5376, 0, "var", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093, type_60), Reflex::Literal("SetUserModules"), method_5377, 0, "value", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2558), Reflex::Literal("GetUserModules"), method_5378, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093), Reflex::Literal("ClearUserModules"), method_5379, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_60, type_60), Reflex::Literal("GetModuleLocation"), method_5380, 0, "mod", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093), Reflex::Literal("SetUserIterator"), method_5381, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2558), Reflex::Literal("GetUserIterator"), method_5382, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093), Reflex::Literal("ClearUserIterator"), method_5383, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2559, type_2100), Reflex::Literal("DecodeProvInfo"), method_5384, 0, "ProvInfo", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<ClusterSummary> -------------------------------
static void constructor_17602( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<ClusterSummary>();
  else ::new(mem) ::edm::Wrapper<ClusterSummary>();
}

static void constructor_17603( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<ClusterSummary>(*(::std::auto_ptr<ClusterSummary>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<ClusterSummary>(*(::std::auto_ptr<ClusterSummary>*)arg[0]);
}

static void destructor_17604(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<ClusterSummary>*)o)->::edm::Wrapper<ClusterSummary>::~Wrapper)();
}
static  void method_17605( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<ClusterSummary>*)o)->product)());
  else   (((const ::edm::Wrapper<ClusterSummary>*)o)->product)();
}

static  void operator_17606( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<ClusterSummary>*)o)->operator->)());
  else   (((const ::edm::Wrapper<ClusterSummary>*)o)->operator->)();
}

static  void method_17607( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<ClusterSummary>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<ClusterSummary>*)o)->productTypeInfo)();
}

static  void method_17608( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<ClusterSummary>*)o)->typeInfo)();
  else   (((::edm::Wrapper<ClusterSummary>*)o)->typeInfo)();
}

static void constructor_17609( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<ClusterSummary>((::ClusterSummary*)arg[0]);
  else ::new(mem) ::edm::Wrapper<ClusterSummary>((::ClusterSummary*)arg[0]);
}

static  void method_17610( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<ClusterSummary>*)o)->getInterface)());
  else   (((::edm::Wrapper<ClusterSummary>*)o)->getInterface)();
}

static  void method_17611( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<ClusterSummary>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_17612( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<ClusterSummary>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_17613( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<ClusterSummary>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_17614( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<ClusterSummary>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<ClusterSummary>*)o)->dynamicTypeInfo)();
}

static  void method_17615( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<ClusterSummary>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<ClusterSummary>*)o)->isPresent)();
}

static  void method_17616( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<ClusterSummary>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<ClusterSummary>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_3977( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<ClusterSummary> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<ClusterSummary> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<ClusterSummary> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<ClusterSummary> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<ClusterSummary> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<ClusterSummary> -------------------------------
void __edm__Wrapper_ClusterSummary__db_datamem(Reflex::Class*);
void __edm__Wrapper_ClusterSummary__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_ClusterSummary__datamem_bld(&__edm__Wrapper_ClusterSummary__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_ClusterSummary__funcmem_bld(&__edm__Wrapper_ClusterSummary__db_funcmem);
void __edm__Wrapper_ClusterSummary__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<ClusterSummary>"), typeid(::edm::Wrapper<ClusterSummary>), sizeof(::edm::Wrapper<ClusterSummary>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_1418, Reflex::Literal("edm::Wrapper<ClusterSummary>::value_type"))
  .AddTypedef(type_1418, Reflex::Literal("edm::Wrapper<ClusterSummary>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_17602, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2317), Reflex::Literal("Wrapper"), constructor_17603, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_17604, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_27154), Reflex::Literal("Wrapper"), constructor_17609, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_3977, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_ClusterSummary__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_ClusterSummary__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<ClusterSummary> -------------------
void __edm__Wrapper_ClusterSummary__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3128, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_ClusterSummary_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1418, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_ClusterSummary_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<ClusterSummary> -------------------
void __edm__Wrapper_ClusterSummary__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27153), Reflex::Literal("product"), method_17605, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27153), Reflex::Literal("operator->"), operator_17606, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3937), Reflex::Literal("productTypeInfo"), method_17607, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3937), Reflex::Literal("typeInfo"), method_17608, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_27155), Reflex::Literal("getInterface"), method_17610, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093, type_17750, type_22713, type_23280), Reflex::Literal("fillView"), method_17611, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093, type_3937, type_302, type_7012), Reflex::Literal("setPtr"), method_17612, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3093, type_3937, type_22714, type_22713), Reflex::Literal("fillPtrVector"), method_17613, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3937), Reflex::Literal("dynamicTypeInfo"), method_17614, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3128), Reflex::Literal("isPresent"), method_17615, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3937), Reflex::Literal("dynamicTypeInfo_"), method_17616, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __ClusterSummary_dict(); 
      __edm__Wrapper_ClusterSummary__dict(); 
    }
    ~Dictionaries() {
      type_1418.Unload(); // class ClusterSummary 
      type_3977.Unload(); // class edm::Wrapper<ClusterSummary> 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
