// Generated at Fri Nov 16 19:12:43 2012. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/afs/cern.ch/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/afs/cern.ch/cms/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_CPP="/afs/cern.ch/cms/slc5_amd64_gcc462/external/gccxml/20110825/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='1' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.6.2"' -D__UINT64_C(c)='c ## UL' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__GNUC_MINOR__='6' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -iwrapper"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9/GCC/4.6" -isystem"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2" -isystem"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/x86_64-unknown-linux-gnu" -isystem"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/../../../../include/c++/4.6.2/backward" -isystem"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include" -isystem"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.6.2/include-fixed" -isystem"/usr/local/include" -isystem"/afs/cern.ch/cms/slc5_amd64_gcc462/external/gcc/4.6.2/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/afs/cern.ch/cms/slc5_amd64_gcc462/external/gccxml/20110825/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.6.2
Copyright (C) 2011 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/data1/aferapon/BH/BlackHolesAnalysis_8TeV/BlackHolesAnalysis_533_PF/CMSSW_5_3_3/src/DPGAnalysis/SiStripTools/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::Type type_72 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_347 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_273 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_3664 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_61 = ::Reflex::TypeBuilder(Reflex::Literal("TinyEvent"));
  ::Reflex::Type type_3863 = ::Reflex::TypeBuilder(Reflex::Literal("long long"));
  ::Reflex::Type type_4843 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Event"));
  ::Reflex::Type type_314 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned int"));
  ::Reflex::Type type_306 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_4537 = ::Reflex::TypeBuilder(Reflex::Literal("edm::InputTag"));
  ::Reflex::Type type_2368 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_4733 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_321 = ::Reflex::TypeBuilder(Reflex::Literal("EventWithHistory"));
  ::Reflex::Type type_4543 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EventSetup"));
  ::Reflex::Type type_2857 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<int>"));
  ::Reflex::Type type_4790 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ParameterSet"));
  ::Reflex::Type type_4803 = ::Reflex::TypeBuilder(Reflex::Literal("edm::EventAuxiliary"));
  ::Reflex::Type type_288 = ::Reflex::TypeBuilder(Reflex::Literal("APVCyclePhaseCollection"));
  ::Reflex::Type type_1352 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<TinyEvent>"));
  ::Reflex::Type type_2225 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_2850 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_3282 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<TinyEvent>"));
  ::Reflex::Type type_2851 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_4566 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<EventWithHistory>"));
  ::Reflex::Type type_2528 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<EventWithHistory>"));
  ::Reflex::Type type_2903 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<edm::EventAuxiliary>"));
  ::Reflex::Type type_1290 = ::Reflex::TypeBuilder(Reflex::Literal("ClusterSummarySingleMultiplicity"));
  ::Reflex::Type type_1665 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<L1AcceptBunchCrossing>"));
  ::Reflex::Type type_3062 = ::Reflex::TypeBuilder(Reflex::Literal("std::map<std::basic_string<char>,int>"));
  ::Reflex::Type type_2852 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<std::basic_string<char> >"));
  ::Reflex::Type type_4565 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<APVCyclePhaseCollection>"));
  ::Reflex::Type type_4567 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<TinyEvent> >"));
  ::Reflex::Type type_2527 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<APVCyclePhaseCollection>"));
  ::Reflex::Type type_2529 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<TinyEvent> >"));
  ::Reflex::Type type_4579 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<EventWithHistory>"));
  ::Reflex::Type type_4578 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<APVCyclePhaseCollection>"));
  ::Reflex::Type type_4580 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<TinyEvent> >"));
  ::Reflex::Type type_1444 = ::Reflex::TypeBuilder(Reflex::Literal("SingleMultiplicity<edm::DetSetVector<SiStripDigi> >"));
  ::Reflex::Type type_4024 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_46 = ::Reflex::TypeBuilder(Reflex::Literal("SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >"));
  ::Reflex::Type type_2218 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TinyEvent,std::allocator<TinyEvent> >"));
  ::Reflex::Type type_494 = ::Reflex::TypeBuilder(Reflex::Literal("SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >"));
  ::Reflex::Type type_5483 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >"));
  ::Reflex::Type type_5484 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const TinyEvent*,std::vector<TinyEvent> >"));
  ::Reflex::Type type_981 = ::Reflex::TypeBuilder(Reflex::Literal("MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>"));
  ::Reflex::Type type_3564 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> > >"));
  ::Reflex::Type type_3563 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const TinyEvent*,std::vector<TinyEvent> > >"));
  ::Reflex::Type type_982 = ::Reflex::TypeBuilder(Reflex::Literal("MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >"));
  ::Reflex::Type type_47 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("SingleSiPixelClusterMultiplicity"), type_46);
  ::Reflex::Type type_495 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("SingleSiStripClusterMultiplicity"), type_494);
  ::Reflex::Type type_1445 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("SingleSiStripDigiMultiplicity"), type_1444);
  ::Reflex::Type type_1816 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("ClusterSummaryMultiplicityPair"), type_981);
  ::Reflex::Type type_1901 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("SiPixelClusterSiStripClusterMultiplicityPair"), type_982);
  ::Reflex::Type type_314c = ::Reflex::ConstBuilder(type_314);
  ::Reflex::Type type_72c = ::Reflex::ConstBuilder(type_72);
  ::Reflex::Type type_61c = ::Reflex::ConstBuilder(type_61);
  ::Reflex::Type type_6134 = ::Reflex::ReferenceBuilder(type_61c);
  ::Reflex::Type type_4843c = ::Reflex::ConstBuilder(type_4843);
  ::Reflex::Type type_19753 = ::Reflex::ReferenceBuilder(type_4843c);
  ::Reflex::Type type_4803c = ::Reflex::ConstBuilder(type_4803);
  ::Reflex::Type type_19759 = ::Reflex::ReferenceBuilder(type_4803c);
  ::Reflex::Type type_6132 = ::Reflex::ReferenceBuilder(type_61);
  ::Reflex::Type type_19885 = ::Reflex::ReferenceBuilder(type_288);
  ::Reflex::Type type_288c = ::Reflex::ConstBuilder(type_288);
  ::Reflex::Type type_19886 = ::Reflex::ReferenceBuilder(type_288c);
  ::Reflex::Type type_3062c = ::Reflex::ConstBuilder(type_3062);
  ::Reflex::Type type_19887 = ::Reflex::ReferenceBuilder(type_3062c);
  ::Reflex::Type type_19888 = ::Reflex::ReferenceBuilder(type_3062);
  ::Reflex::Type type_2226 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2225);
  ::Reflex::Type type_2226c = ::Reflex::ConstBuilder(type_2226);
  ::Reflex::Type type_2857c = ::Reflex::ConstBuilder(type_2857);
  ::Reflex::Type type_2903c = ::Reflex::ConstBuilder(type_2903);
  ::Reflex::Type type_19910 = ::Reflex::ReferenceBuilder(type_2903c);
  ::Reflex::Type type_1666 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("L1AcceptBunchCrossingCollection"), type_1665);
  ::Reflex::Type type_1666c = ::Reflex::ConstBuilder(type_1666);
  ::Reflex::Type type_19911 = ::Reflex::ReferenceBuilder(type_1666c);
  ::Reflex::Type type_3863c = ::Reflex::ConstBuilder(type_3863);
  ::Reflex::Type type_321c = ::Reflex::ConstBuilder(type_321);
  ::Reflex::Type type_19913 = ::Reflex::ReferenceBuilder(type_321c);
  ::Reflex::Type type_19914 = ::Reflex::ReferenceBuilder(type_321);
  ::Reflex::Type type_6130 = ::Reflex::PointerBuilder(type_61c);
  ::Reflex::Type type_28857 = ::Reflex::ReferenceBuilder(type_1290);
  ::Reflex::Type type_1290c = ::Reflex::ConstBuilder(type_1290);
  ::Reflex::Type type_28858 = ::Reflex::ReferenceBuilder(type_1290c);
  ::Reflex::Type type_4790c = ::Reflex::ConstBuilder(type_4790);
  ::Reflex::Type type_13536 = ::Reflex::ReferenceBuilder(type_4790c);
  ::Reflex::Type type_4543c = ::Reflex::ConstBuilder(type_4543);
  ::Reflex::Type type_19754 = ::Reflex::ReferenceBuilder(type_4543c);
  ::Reflex::Type type_6128 = ::Reflex::PointerBuilder(type_61);
  ::Reflex::Type type_2839 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_306);
  ::Reflex::Type type_3017 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_273);
  ::Reflex::Type type_3282c = ::Reflex::ConstBuilder(type_3282);
  ::Reflex::Type type_28870 = ::Reflex::ReferenceBuilder(type_3282c);
  ::Reflex::Type type_1352c = ::Reflex::ConstBuilder(type_1352);
  ::Reflex::Type type_28871 = ::Reflex::ReferenceBuilder(type_1352c);
  ::Reflex::Type type_28872 = ::Reflex::ReferenceBuilder(type_1352);
  ::Reflex::Type type_37549 = ::Reflex::PointerBuilder(type_288c);
  ::Reflex::Type type_2368c = ::Reflex::ConstBuilder(type_2368);
  ::Reflex::Type type_4502 = ::Reflex::ReferenceBuilder(type_2368c);
  ::Reflex::Type type_37550 = ::Reflex::PointerBuilder(type_288);
  ::Reflex::Type type_4578c = ::Reflex::ConstBuilder(type_4578);
  ::Reflex::Type type_37551 = ::Reflex::PointerBuilder(type_4578c);
  ::Reflex::Type type_4733c = ::Reflex::ConstBuilder(type_4733);
  ::Reflex::Type type_19815 = ::Reflex::ReferenceBuilder(type_4733c);
  ::Reflex::Type type_32307 = ::Reflex::ReferenceBuilder(type_2850);
  ::Reflex::Type type_33253 = ::Reflex::ReferenceBuilder(type_4024);
  ::Reflex::Type type_347c = ::Reflex::ConstBuilder(type_347);
  ::Reflex::Type type_3811 = ::Reflex::PointerBuilder(type_347c);
  ::Reflex::Type type_7791 = ::Reflex::ReferenceBuilder(type_3811);
  ::Reflex::Type type_2851c = ::Reflex::ConstBuilder(type_2851);
  ::Reflex::Type type_32308 = ::Reflex::ReferenceBuilder(type_2851c);
  ::Reflex::Type type_37554 = ::Reflex::PointerBuilder(type_321c);
  ::Reflex::Type type_37555 = ::Reflex::PointerBuilder(type_321);
  ::Reflex::Type type_4579c = ::Reflex::ConstBuilder(type_4579);
  ::Reflex::Type type_37556 = ::Reflex::PointerBuilder(type_4579c);
  ::Reflex::Type type_37559 = ::Reflex::PointerBuilder(type_1352c);
  ::Reflex::Type type_37560 = ::Reflex::PointerBuilder(type_1352);
  ::Reflex::Type type_4580c = ::Reflex::ConstBuilder(type_4580);
  ::Reflex::Type type_37561 = ::Reflex::PointerBuilder(type_4580c);
  ::Reflex::Type type_19751 = ::Reflex::ReferenceBuilder(type_46);
  ::Reflex::Type type_46c = ::Reflex::ConstBuilder(type_46);
  ::Reflex::Type type_19752 = ::Reflex::ReferenceBuilder(type_46c);
  ::Reflex::Type type_25318 = ::Reflex::ReferenceBuilder(type_494);
  ::Reflex::Type type_494c = ::Reflex::ConstBuilder(type_494);
  ::Reflex::Type type_25319 = ::Reflex::ReferenceBuilder(type_494c);
  ::Reflex::Type type_30004 = ::Reflex::ReferenceBuilder(type_1444);
  ::Reflex::Type type_1444c = ::Reflex::ConstBuilder(type_1444);
  ::Reflex::Type type_30005 = ::Reflex::ReferenceBuilder(type_1444c);
  ::Reflex::Type type_28775 = ::Reflex::ReferenceBuilder(type_981);
  ::Reflex::Type type_981c = ::Reflex::ConstBuilder(type_981);
  ::Reflex::Type type_28776 = ::Reflex::ReferenceBuilder(type_981c);
  ::Reflex::Type type_28777 = ::Reflex::ReferenceBuilder(type_982);
  ::Reflex::Type type_982c = ::Reflex::ConstBuilder(type_982);
  ::Reflex::Type type_28778 = ::Reflex::ReferenceBuilder(type_982c);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __TinyEvent
#undef __TinyEvent
#endif
struct __TinyEvent {
  public:
  __TinyEvent();
  unsigned int _event;
  unsigned int _orbit;
  unsigned int _bx;
};
#ifdef __APVCyclePhaseCollection
#undef __APVCyclePhaseCollection
#endif
class __APVCyclePhaseCollection {
  public:
  __APVCyclePhaseCollection();
  ::std::map<std::basic_string<char>,int> _apvmap;
};
#ifdef __EventWithHistory
#undef __EventWithHistory
#endif
class __EventWithHistory : public ::TinyEvent {
  public:
  __EventWithHistory();
  ::std::vector<TinyEvent> _prevse;
};
#ifdef __ClusterSummarySingleMultiplicity
#undef __ClusterSummarySingleMultiplicity
#endif
class __ClusterSummarySingleMultiplicity {
  public:
  __ClusterSummarySingleMultiplicity();
  ::edm::InputTag m_collection;
  int m_subdetenum;
  ::std::string m_subdetvar;
  ::std::vector<std::basic_string<char> > m_clustsummvar;
  int m_mult;
};
#ifdef __std__vector_TinyEvent_
#undef __std__vector_TinyEvent_
#endif
class __std__vector_TinyEvent_ : protected ::std::_Vector_base<TinyEvent,std::allocator<TinyEvent> > {
  public:
  __std__vector_TinyEvent_();
};
#ifdef __edm__Wrapper_APVCyclePhaseCollection_
#undef __edm__Wrapper_APVCyclePhaseCollection_
#endif
class __edm__Wrapper_APVCyclePhaseCollection_ {
  public:
  __edm__Wrapper_APVCyclePhaseCollection_();
  bool present;
  ::APVCyclePhaseCollection obj;
};
#ifdef __edm__Wrapper_EventWithHistory_
#undef __edm__Wrapper_EventWithHistory_
#endif
class __edm__Wrapper_EventWithHistory_ {
  public:
  __edm__Wrapper_EventWithHistory_();
  bool present;
  ::EventWithHistory obj;
};
#ifdef __edm__Wrapper_std__vector_TinyEvent_s_
#undef __edm__Wrapper_std__vector_TinyEvent_s_
#endif
class __edm__Wrapper_std__vector_TinyEvent_s_ {
  public:
  __edm__Wrapper_std__vector_TinyEvent_s_();
  bool present;
  ::std::vector<TinyEvent> obj;
};
#ifdef __SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s_
#undef __SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s_
#endif
class __SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s_ {
  public:
  __SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s_();
  ::edm::InputTag m_collection;
  int m_modthr;
  bool m_useQuality;
  ::std::basic_string<char> m_qualityLabel;
  int m_mult;
};
#ifdef __SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_
#undef __SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_
#endif
class __SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_ {
  public:
  __SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_();
  ::edm::InputTag m_collection;
  int m_modthr;
  bool m_useQuality;
  ::std::basic_string<char> m_qualityLabel;
  int m_mult;
};
#ifdef __SingleMultiplicity_edm__DetSetVector_SiStripDigi_s_
#undef __SingleMultiplicity_edm__DetSetVector_SiStripDigi_s_
#endif
class __SingleMultiplicity_edm__DetSetVector_SiStripDigi_s_ {
  public:
  __SingleMultiplicity_edm__DetSetVector_SiStripDigi_s_();
  ::edm::InputTag m_collection;
  int m_modthr;
  bool m_useQuality;
  ::std::basic_string<char> m_qualityLabel;
  int m_mult;
};
#ifdef __MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity_
#undef __MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity_
#endif
class __MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity_ {
  public:
  __MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity_();
  ::ClusterSummarySingleMultiplicity m_multiplicity1;
  ::ClusterSummarySingleMultiplicity m_multiplicity2;
};
#ifdef __MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s_
#undef __MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s_
#endif
class __MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s_ {
  public:
  __MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s_();
  ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> > m_multiplicity1;
  ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > m_multiplicity2;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class TinyEvent -------------------------------
static void destructor_3718(void*, void * o, const std::vector<void*>&, void *) {
(((::TinyEvent*)o)->::TinyEvent::~TinyEvent)();
}
static void constructor_3719( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TinyEvent();
  else ::new(mem) ::TinyEvent();
}

static void constructor_3720( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TinyEvent(*(const unsigned int*)arg[0],
      *(const int*)arg[1],
      *(const int*)arg[2]);
  else ::new(mem) ::TinyEvent(*(const unsigned int*)arg[0],
      *(const int*)arg[1],
      *(const int*)arg[2]);
}

static void constructor_3721( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TinyEvent(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1],
      *(const int*)arg[2]);
  else ::new(mem) ::TinyEvent(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1],
      *(const int*)arg[2]);
}

static void constructor_3722( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TinyEvent(*(const ::TinyEvent*)arg[0]);
  else ::new(mem) ::TinyEvent(*(const ::TinyEvent*)arg[0]);
}

static void constructor_3723( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TinyEvent(*(const ::edm::Event*)arg[0]);
  else ::new(mem) ::TinyEvent(*(const ::edm::Event*)arg[0]);
}

static void constructor_3724( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::TinyEvent(*(const ::edm::EventAuxiliary*)arg[0]);
  else ::new(mem) ::TinyEvent(*(const ::edm::EventAuxiliary*)arg[0]);
}

static  void operator_3725( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::TinyEvent*)o)->operator=)(*(const ::TinyEvent*)arg[0]);
  else   (((::TinyEvent*)o)->operator=)(*(const ::TinyEvent*)arg[0]);
}

static  void operator_3726( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TinyEvent*)o)->operator<)(*(const ::TinyEvent*)arg[0]));
  else   (((const ::TinyEvent*)o)->operator<)(*(const ::TinyEvent*)arg[0]);
}

static  void operator_3727( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TinyEvent*)o)->operator==)(*(const ::TinyEvent*)arg[0]));
  else   (((const ::TinyEvent*)o)->operator==)(*(const ::TinyEvent*)arg[0]);
}

static  void method_3728( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::TinyEvent*)o)->isNextOf)(*(const ::TinyEvent*)arg[0]));
  else   (((const ::TinyEvent*)o)->isNextOf)(*(const ::TinyEvent*)arg[0]);
}

static  void method_3729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::TinyEvent*)o)->absoluteBX)());
  else   (((const ::TinyEvent*)o)->absoluteBX)();
}

static  void method_3730( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::TinyEvent*)o)->absoluteBXinCycle)(*(const int*)arg[0]));
  else   (((const ::TinyEvent*)o)->absoluteBXinCycle)(*(const int*)arg[0]);
}

static  void method_3731( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::TinyEvent*)o)->deltaBX)(*(const ::TinyEvent*)arg[0]));
  else   (((const ::TinyEvent*)o)->deltaBX)(*(const ::TinyEvent*)arg[0]);
}

static  void method_3732( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::TinyEvent*)o)->deltaBXinCycle)(*(const ::TinyEvent*)arg[0],
    *(const int*)arg[1]));
  else   (((const ::TinyEvent*)o)->deltaBXinCycle)(*(const ::TinyEvent*)arg[0],
    *(const int*)arg[1]);
}

static void method_newdel_61( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::TinyEvent >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::TinyEvent >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::TinyEvent >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::TinyEvent >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::TinyEvent >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class TinyEvent -------------------------------
void __TinyEvent_db_datamem(Reflex::Class*);
void __TinyEvent_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __TinyEvent_datamem_bld(&__TinyEvent_db_datamem);
Reflex::GenreflexMemberBuilder __TinyEvent_funcmem_bld(&__TinyEvent_db_funcmem);
void __TinyEvent_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("TinyEvent"), typeid(::TinyEvent), sizeof(::TinyEvent), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::STRUCT)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~TinyEvent"), destructor_3718, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("TinyEvent"), constructor_3719, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_314c, type_72c, type_72c), Reflex::Literal("TinyEvent"), constructor_3720, 0, "event;orbit;bx", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_314c, type_314c, type_72c), Reflex::Literal("TinyEvent"), constructor_3721, 0, "event;orbit;bx", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6134), Reflex::Literal("TinyEvent"), constructor_3722, 0, "se", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19753), Reflex::Literal("TinyEvent"), constructor_3723, 0, "event", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19759), Reflex::Literal("TinyEvent"), constructor_3724, 0, "eaux", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_61, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__TinyEvent_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__TinyEvent_funcmem_bld);
}

//------Delayed data member builder for class TinyEvent -------------------
void __TinyEvent_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_314, Reflex::Literal("_event"), OffsetOf(__shadow__::__TinyEvent, _event), ::Reflex::PUBLIC)
  .AddDataMember(type_314, Reflex::Literal("_orbit"), OffsetOf(__shadow__::__TinyEvent, _orbit), ::Reflex::PUBLIC)
  .AddDataMember(type_314, Reflex::Literal("_bx"), OffsetOf(__shadow__::__TinyEvent, _bx), ::Reflex::PUBLIC);
}
//------Delayed function member builder for class TinyEvent -------------------
void __TinyEvent_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6132, type_6134), Reflex::Literal("operator="), operator_3725, 0, "se", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_6134), Reflex::Literal("operator<"), operator_3726, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_6134), Reflex::Literal("operator=="), operator_3727, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_6134), Reflex::Literal("isNextOf"), method_3728, 0, "se", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863), Reflex::Literal("absoluteBX"), method_3729, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_72c), Reflex::Literal("absoluteBXinCycle"), method_3730, 0, "bx0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_6134), Reflex::Literal("deltaBX"), method_3731, 0, "se", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_6134, type_72c), Reflex::Literal("deltaBXinCycle"), method_3732, 0, "se;bx0", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class APVCyclePhaseCollection -------------------------------
static  void operator_3895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::APVCyclePhaseCollection*)o)->operator=)(*(const ::APVCyclePhaseCollection*)arg[0]);
  else   (((::APVCyclePhaseCollection*)o)->operator=)(*(const ::APVCyclePhaseCollection*)arg[0]);
}

static void constructor_3896( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::APVCyclePhaseCollection(*(const ::APVCyclePhaseCollection*)arg[0]);
  else ::new(mem) ::APVCyclePhaseCollection(*(const ::APVCyclePhaseCollection*)arg[0]);
}

static void constructor_3897( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::APVCyclePhaseCollection();
  else ::new(mem) ::APVCyclePhaseCollection();
}

static void destructor_3898(void*, void * o, const std::vector<void*>&, void *) {
(((::APVCyclePhaseCollection*)o)->::APVCyclePhaseCollection::~APVCyclePhaseCollection)();
}
static  void method_3899( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::APVCyclePhaseCollection*)o)->get)();
  else   (((const ::APVCyclePhaseCollection*)o)->get)();
}

static  void method_3900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::APVCyclePhaseCollection*)o)->get)();
  else   (((::APVCyclePhaseCollection*)o)->get)();
}

static  void method_3901( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::APVCyclePhaseCollection*)o)->getPhase)(*(const ::std::string*)arg[0]));
  else   (((const ::APVCyclePhaseCollection*)o)->getPhase)(*(const ::std::string*)arg[0]);
}

static  void method_3902( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (std::vector<int>)((((const ::APVCyclePhaseCollection*)o)->getPhases)(*(const ::std::string*)arg[0]));
  else   (((const ::APVCyclePhaseCollection*)o)->getPhases)(*(const ::std::string*)arg[0]);
}

static void method_newdel_288( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::APVCyclePhaseCollection >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::APVCyclePhaseCollection >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::APVCyclePhaseCollection >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::APVCyclePhaseCollection >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::APVCyclePhaseCollection >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class APVCyclePhaseCollection -------------------------------
void __APVCyclePhaseCollection_db_datamem(Reflex::Class*);
void __APVCyclePhaseCollection_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __APVCyclePhaseCollection_datamem_bld(&__APVCyclePhaseCollection_db_datamem);
Reflex::GenreflexMemberBuilder __APVCyclePhaseCollection_funcmem_bld(&__APVCyclePhaseCollection_db_funcmem);
void __APVCyclePhaseCollection_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("APVCyclePhaseCollection"), typeid(::APVCyclePhaseCollection), sizeof(::APVCyclePhaseCollection), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("persistent"), "false")
  .AddEnum(Reflex::Literal("_69"), Reflex::Literal("nopartition=-91;multiphase=-92;empty=-98;invalid=-99"), &typeid(::Reflex::UnnamedEnum), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19885, type_19886), Reflex::Literal("operator="), operator_3895, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19886), Reflex::Literal("APVCyclePhaseCollection"), constructor_3896, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("APVCyclePhaseCollection"), constructor_3897, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~APVCyclePhaseCollection"), destructor_3898, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_288, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__APVCyclePhaseCollection_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__APVCyclePhaseCollection_funcmem_bld);
}

//------Delayed data member builder for class APVCyclePhaseCollection -------------------
void __APVCyclePhaseCollection_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3062, Reflex::Literal("_apvmap"), OffsetOf(__shadow__::__APVCyclePhaseCollection, _apvmap), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class APVCyclePhaseCollection -------------------
void __APVCyclePhaseCollection_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19887), Reflex::Literal("get"), method_3899, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19888), Reflex::Literal("get"), method_3900, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72c, type_2226c), Reflex::Literal("getPhase"), method_3901, 0, "partition", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2857c, type_2226c), Reflex::Literal("getPhases"), method_3902, 0, "partition", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class EventWithHistory -------------------------------
static void destructor_3919(void*, void * o, const std::vector<void*>&, void *) {
(((::EventWithHistory*)o)->::EventWithHistory::~EventWithHistory)();
}
static void constructor_3920( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EventWithHistory();
  else ::new(mem) ::EventWithHistory();
}

static void constructor_3921( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EventWithHistory(*(const ::TinyEvent*)arg[0]);
  else ::new(mem) ::EventWithHistory(*(const ::TinyEvent*)arg[0]);
}

static void constructor_3922( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EventWithHistory(*(const unsigned int*)arg[0],
      *(const int*)arg[1],
      *(const int*)arg[2]);
  else ::new(mem) ::EventWithHistory(*(const unsigned int*)arg[0],
      *(const int*)arg[1],
      *(const int*)arg[2]);
}

static void constructor_3923( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EventWithHistory(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1],
      *(const int*)arg[2]);
  else ::new(mem) ::EventWithHistory(*(const unsigned int*)arg[0],
      *(const unsigned int*)arg[1],
      *(const int*)arg[2]);
}

static void constructor_3924( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EventWithHistory(*(const ::edm::Event*)arg[0]);
  else ::new(mem) ::EventWithHistory(*(const ::edm::Event*)arg[0]);
}

static void constructor_3925( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EventWithHistory(*(const ::std::vector<edm::EventAuxiliary>*)arg[0]);
  else ::new(mem) ::EventWithHistory(*(const ::std::vector<edm::EventAuxiliary>*)arg[0]);
}

static void constructor_3926( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 2 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::EventWithHistory(*(const ::edm::Event*)arg[0],
      *(const ::L1AcceptBunchCrossingCollection*)arg[1]);
  else ::new(mem) ::EventWithHistory(*(const ::edm::Event*)arg[0],
      *(const ::L1AcceptBunchCrossingCollection*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::EventWithHistory(*(const ::edm::Event*)arg[0],
      *(const ::L1AcceptBunchCrossingCollection*)arg[1],
      *(const long long*)arg[2]);
  else ::new(mem) ::EventWithHistory(*(const ::edm::Event*)arg[0],
      *(const ::L1AcceptBunchCrossingCollection*)arg[1],
      *(const long long*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::EventWithHistory(*(const ::edm::Event*)arg[0],
      *(const ::L1AcceptBunchCrossingCollection*)arg[1],
      *(const long long*)arg[2],
      *(const int*)arg[3]);
  else ::new(mem) ::EventWithHistory(*(const ::edm::Event*)arg[0],
      *(const ::L1AcceptBunchCrossingCollection*)arg[1],
      *(const long long*)arg[2],
      *(const int*)arg[3]);
  }
}

static void constructor_3927( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::EventWithHistory(*(const ::EventWithHistory*)arg[0]);
  else ::new(mem) ::EventWithHistory(*(const ::EventWithHistory*)arg[0]);
}

static  void operator_3928( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::EventWithHistory*)o)->operator=)(*(const ::EventWithHistory*)arg[0]);
  else   (((::EventWithHistory*)o)->operator=)(*(const ::EventWithHistory*)arg[0]);
}

static  void operator_3929( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::EventWithHistory*)o)->operator==)(*(const ::EventWithHistory*)arg[0]));
  else   (((const ::EventWithHistory*)o)->operator==)(*(const ::EventWithHistory*)arg[0]);
}

static  void method_3930( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::EventWithHistory*)o)->add)(*(const ::EventWithHistory*)arg[0],
    *(const int*)arg[1]));
  else   (((::EventWithHistory*)o)->add)(*(const ::EventWithHistory*)arg[0],
    *(const int*)arg[1]);
}

static  void method_3931( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (int)((((::EventWithHistory*)o)->add)(*(const ::TinyEvent*)arg[0],
    *(const int*)arg[1]));
  else   (((::EventWithHistory*)o)->add)(*(const ::TinyEvent*)arg[0],
    *(const int*)arg[1]);
}

static  void method_3932( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::EventWithHistory*)o)->event)());
  else   (((const ::EventWithHistory*)o)->event)();
}

static  void method_3933( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::EventWithHistory*)o)->orbit)());
  else   (((const ::EventWithHistory*)o)->orbit)();
}

static  void method_3934( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::EventWithHistory*)o)->bx)());
  else   (((const ::EventWithHistory*)o)->bx)();
}

static  void method_3935( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::EventWithHistory*)o)->get)(*(const unsigned int*)arg[0]));
  else   (((const ::EventWithHistory*)o)->get)(*(const unsigned int*)arg[0]);
}

static  void method_3936( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (unsigned int)((((const ::EventWithHistory*)o)->depth)());
  else   (((const ::EventWithHistory*)o)->depth)();
}

static  void method_3937( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::EventWithHistory*)o)->isFutureHistory)());
  else   (((const ::EventWithHistory*)o)->isFutureHistory)();
}

static  void method_3938( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::EventWithHistory*)o)->deltaBX)(*(const unsigned int*)arg[0],
    *(const unsigned int*)arg[1]));
  else   (((const ::EventWithHistory*)o)->deltaBX)(*(const unsigned int*)arg[0],
    *(const unsigned int*)arg[1]);
}

static  void method_3939( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::EventWithHistory*)o)->deltaBX)(*(const unsigned int*)arg[0]));
  else   (((const ::EventWithHistory*)o)->deltaBX)(*(const unsigned int*)arg[0]);
}

static  void method_3940( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::EventWithHistory*)o)->deltaBX)());
  else   (((const ::EventWithHistory*)o)->deltaBX)();
}

static  void method_3941( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::EventWithHistory*)o)->deltaBX)(*(const ::TinyEvent*)arg[0]));
  else   (((const ::EventWithHistory*)o)->deltaBX)(*(const ::TinyEvent*)arg[0]);
}

static  void method_3942( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::EventWithHistory*)o)->absoluteBX)(*(const unsigned int*)arg[0]));
  else   (((const ::EventWithHistory*)o)->absoluteBX)(*(const unsigned int*)arg[0]);
}

static  void method_3943( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::EventWithHistory*)o)->absoluteBX)());
  else   (((const ::EventWithHistory*)o)->absoluteBX)();
}

static  void method_3944( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::EventWithHistory*)o)->absoluteBXinCycle)(*(const unsigned int*)arg[0],
    *(const int*)arg[1]));
  else   (((const ::EventWithHistory*)o)->absoluteBXinCycle)(*(const unsigned int*)arg[0],
    *(const int*)arg[1]);
}

static  void method_3945( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::EventWithHistory*)o)->absoluteBXinCycle)(*(const int*)arg[0]));
  else   (((const ::EventWithHistory*)o)->absoluteBXinCycle)(*(const int*)arg[0]);
}

static  void method_3946( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::EventWithHistory*)o)->deltaBXinCycle)(*(const unsigned int*)arg[0],
    *(const unsigned int*)arg[1],
    *(const int*)arg[2]));
  else   (((const ::EventWithHistory*)o)->deltaBXinCycle)(*(const unsigned int*)arg[0],
    *(const unsigned int*)arg[1],
    *(const int*)arg[2]);
}

static  void method_3947( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::EventWithHistory*)o)->deltaBXinCycle)(*(const unsigned int*)arg[0],
    *(const int*)arg[1]));
  else   (((const ::EventWithHistory*)o)->deltaBXinCycle)(*(const unsigned int*)arg[0],
    *(const int*)arg[1]);
}

static  void method_3948( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::EventWithHistory*)o)->deltaBXinCycle)(*(const int*)arg[0]));
  else   (((const ::EventWithHistory*)o)->deltaBXinCycle)(*(const int*)arg[0]);
}

static  void method_3949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (long long)((((const ::EventWithHistory*)o)->deltaBXinCycle)(*(const ::TinyEvent*)arg[0],
    *(const int*)arg[1]));
  else   (((const ::EventWithHistory*)o)->deltaBXinCycle)(*(const ::TinyEvent*)arg[0],
    *(const int*)arg[1]);
}

static void method_newdel_321( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::EventWithHistory >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::EventWithHistory >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::EventWithHistory >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::EventWithHistory >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::EventWithHistory >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x3( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("TinyEvent")), ::Reflex::BaseOffset< ::EventWithHistory,::TinyEvent >::Get(),::Reflex::PUBLIC), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

//------Dictionary for class EventWithHistory -------------------------------
void __EventWithHistory_db_datamem(Reflex::Class*);
void __EventWithHistory_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __EventWithHistory_datamem_bld(&__EventWithHistory_db_datamem);
Reflex::GenreflexMemberBuilder __EventWithHistory_funcmem_bld(&__EventWithHistory_db_funcmem);
void __EventWithHistory_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("EventWithHistory"), typeid(::EventWithHistory), sizeof(::EventWithHistory), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("persistent"), "false")
  .AddBase(type_61, ::Reflex::BaseOffset< ::EventWithHistory, ::TinyEvent >::Get(), ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~EventWithHistory"), destructor_3919, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("EventWithHistory"), constructor_3920, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_6134), Reflex::Literal("EventWithHistory"), constructor_3921, 0, "se", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_314c, type_72c, type_72c), Reflex::Literal("EventWithHistory"), constructor_3922, 0, "event;orbit;bx", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_314c, type_314c, type_72c), Reflex::Literal("EventWithHistory"), constructor_3923, 0, "event;orbit;bx", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19753), Reflex::Literal("EventWithHistory"), constructor_3924, 0, "event", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19910), Reflex::Literal("EventWithHistory"), constructor_3925, 0, "he", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19753, type_19911, type_3863c, type_72c), Reflex::Literal("EventWithHistory"), constructor_3926, 0, "event;l11bcc;orbitoffset=0;bxoffset=0", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19913), Reflex::Literal("EventWithHistory"), constructor_3927, 0, "he", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_321, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x3, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__EventWithHistory_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__EventWithHistory_funcmem_bld);
}

//------Delayed data member builder for class EventWithHistory -------------------
void __EventWithHistory_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1352, Reflex::Literal("_prevse"), OffsetOf(__shadow__::__EventWithHistory, _prevse), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class EventWithHistory -------------------
void __EventWithHistory_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19914, type_19913), Reflex::Literal("operator="), operator_3928, 0, "he", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_19913), Reflex::Literal("operator=="), operator_3929, 0, "other", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_19913, type_72c), Reflex::Literal("add"), method_3930, 0, "he;idepth", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72, type_6134, type_72c), Reflex::Literal("add"), method_3931, 0, "he;idepth", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_314c), Reflex::Literal("event"), method_3932, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_314c), Reflex::Literal("orbit"), method_3933, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72c), Reflex::Literal("bx"), method_3934, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6130, type_314c), Reflex::Literal("get"), method_3935, 0, "ev", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_314), Reflex::Literal("depth"), method_3936, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3664), Reflex::Literal("isFutureHistory"), method_3937, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_314c, type_314c), Reflex::Literal("deltaBX"), method_3938, 0, "ev2;ev1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_314c), Reflex::Literal("deltaBX"), method_3939, 0, "ev1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863), Reflex::Literal("deltaBX"), method_3940, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_6134), Reflex::Literal("deltaBX"), method_3941, 0, "se", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_314c), Reflex::Literal("absoluteBX"), method_3942, 0, "ev1", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863), Reflex::Literal("absoluteBX"), method_3943, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_314c, type_72c), Reflex::Literal("absoluteBXinCycle"), method_3944, 0, "ev1;bx0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_72c), Reflex::Literal("absoluteBXinCycle"), method_3945, 0, "bx0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_314c, type_314c, type_72c), Reflex::Literal("deltaBXinCycle"), method_3946, 0, "ev2;ev1;bx0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_314c, type_72c), Reflex::Literal("deltaBXinCycle"), method_3947, 0, "ev1;bx0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_72c), Reflex::Literal("deltaBXinCycle"), method_3948, 0, "bx0", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3863, type_6134, type_72c), Reflex::Literal("deltaBXinCycle"), method_3949, 0, "se;bx0", ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class ClusterSummarySingleMultiplicity -------------------------------
static void destructor_6103(void*, void * o, const std::vector<void*>&, void *) {
(((::ClusterSummarySingleMultiplicity*)o)->::ClusterSummarySingleMultiplicity::~ClusterSummarySingleMultiplicity)();
}
static  void operator_6104( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::ClusterSummarySingleMultiplicity*)o)->operator=)(*(const ::ClusterSummarySingleMultiplicity*)arg[0]);
  else   (((::ClusterSummarySingleMultiplicity*)o)->operator=)(*(const ::ClusterSummarySingleMultiplicity*)arg[0]);
}

static void constructor_6105( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ClusterSummarySingleMultiplicity(*(const ::ClusterSummarySingleMultiplicity*)arg[0]);
  else ::new(mem) ::ClusterSummarySingleMultiplicity(*(const ::ClusterSummarySingleMultiplicity*)arg[0]);
}

static void constructor_6106( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ClusterSummarySingleMultiplicity();
  else ::new(mem) ::ClusterSummarySingleMultiplicity();
}

static void constructor_6107( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::ClusterSummarySingleMultiplicity(*(const ::edm::ParameterSet*)arg[0]);
  else ::new(mem) ::ClusterSummarySingleMultiplicity(*(const ::edm::ParameterSet*)arg[0]);
}

static  void method_6108( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::ClusterSummarySingleMultiplicity*)o)->getEvent)(*(const ::edm::Event*)arg[0],
    *(const ::edm::EventSetup*)arg[1]);
}

static  void method_6109( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::ClusterSummarySingleMultiplicity*)o)->mult)());
  else   (((const ::ClusterSummarySingleMultiplicity*)o)->mult)();
}

static void method_newdel_1290( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::ClusterSummarySingleMultiplicity >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::ClusterSummarySingleMultiplicity >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::ClusterSummarySingleMultiplicity >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::ClusterSummarySingleMultiplicity >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::ClusterSummarySingleMultiplicity >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class ClusterSummarySingleMultiplicity -------------------------------
void __ClusterSummarySingleMultiplicity_db_datamem(Reflex::Class*);
void __ClusterSummarySingleMultiplicity_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __ClusterSummarySingleMultiplicity_datamem_bld(&__ClusterSummarySingleMultiplicity_db_datamem);
Reflex::GenreflexMemberBuilder __ClusterSummarySingleMultiplicity_funcmem_bld(&__ClusterSummarySingleMultiplicity_db_funcmem);
void __ClusterSummarySingleMultiplicity_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("ClusterSummarySingleMultiplicity"), typeid(::ClusterSummarySingleMultiplicity), sizeof(::ClusterSummarySingleMultiplicity), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("persistent"), "false")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~ClusterSummarySingleMultiplicity"), destructor_6103, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28857, type_28858), Reflex::Literal("operator="), operator_6104, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28858), Reflex::Literal("ClusterSummarySingleMultiplicity"), constructor_6105, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("ClusterSummarySingleMultiplicity"), constructor_6106, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13536), Reflex::Literal("ClusterSummarySingleMultiplicity"), constructor_6107, 0, "iConfig", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1290, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__ClusterSummarySingleMultiplicity_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__ClusterSummarySingleMultiplicity_funcmem_bld);
}

//------Delayed data member builder for class ClusterSummarySingleMultiplicity -------------------
void __ClusterSummarySingleMultiplicity_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4537, Reflex::Literal("m_collection"), OffsetOf(__shadow__::__ClusterSummarySingleMultiplicity, m_collection), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("m_subdetenum"), OffsetOf(__shadow__::__ClusterSummarySingleMultiplicity, m_subdetenum), ::Reflex::PRIVATE)
  .AddDataMember(type_2226, Reflex::Literal("m_subdetvar"), OffsetOf(__shadow__::__ClusterSummarySingleMultiplicity, m_subdetvar), ::Reflex::PRIVATE)
  .AddDataMember(type_2852, Reflex::Literal("m_clustsummvar"), OffsetOf(__shadow__::__ClusterSummarySingleMultiplicity, m_clustsummvar), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("m_mult"), OffsetOf(__shadow__::__ClusterSummarySingleMultiplicity, m_mult), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class ClusterSummarySingleMultiplicity -------------------
void __ClusterSummarySingleMultiplicity_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_19753, type_19754), Reflex::Literal("getEvent"), method_6108, 0, "iEvent;iSetup", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("mult"), method_6109, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<TinyEvent,std::allocator<TinyEvent> > -------------------------------
static void constructor_6143( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TinyEvent>();
  else ::new(mem) ::std::vector<TinyEvent>();
}

static void constructor_6144( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TinyEvent>(*(const ::std::allocator<TinyEvent>*)arg[0]);
  else ::new(mem) ::std::vector<TinyEvent>(*(const ::std::allocator<TinyEvent>*)arg[0]);
}

static void constructor_6145( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TinyEvent>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<TinyEvent>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TinyEvent>(*(::std::size_t*)arg[0],
      *(const ::TinyEvent*)arg[1]);
  else ::new(mem) ::std::vector<TinyEvent>(*(::std::size_t*)arg[0],
      *(const ::TinyEvent*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TinyEvent>(*(::std::size_t*)arg[0],
      *(const ::TinyEvent*)arg[1],
      *(const ::std::allocator<TinyEvent>*)arg[2]);
  else ::new(mem) ::std::vector<TinyEvent>(*(::std::size_t*)arg[0],
      *(const ::TinyEvent*)arg[1],
      *(const ::std::allocator<TinyEvent>*)arg[2]);
  }
}

static void constructor_6146( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<TinyEvent>(*(const ::std::vector<TinyEvent>*)arg[0]);
  else ::new(mem) ::std::vector<TinyEvent>(*(const ::std::vector<TinyEvent>*)arg[0]);
}

static void destructor_6147(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<TinyEvent>*)o)->::std::vector<TinyEvent>::~vector)();
}
static  void operator_6148( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TinyEvent>*)o)->operator=)(*(const ::std::vector<TinyEvent>*)arg[0]);
  else   (((::std::vector<TinyEvent>*)o)->operator=)(*(const ::std::vector<TinyEvent>*)arg[0]);
}

static  void method_6149( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TinyEvent>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::TinyEvent*)arg[1]);
}

static  void method_6150( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >)((((::std::vector<TinyEvent>*)o)->begin)());
  else   (((::std::vector<TinyEvent>*)o)->begin)();
}

static  void method_6151( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TinyEvent*,std::vector<TinyEvent> >)((((const ::std::vector<TinyEvent>*)o)->begin)());
  else   (((const ::std::vector<TinyEvent>*)o)->begin)();
}

static  void method_6152( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >)((((::std::vector<TinyEvent>*)o)->end)());
  else   (((::std::vector<TinyEvent>*)o)->end)();
}

static  void method_6153( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const TinyEvent*,std::vector<TinyEvent> >)((((const ::std::vector<TinyEvent>*)o)->end)());
  else   (((const ::std::vector<TinyEvent>*)o)->end)();
}

static  void method_6158( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TinyEvent>*)o)->size)());
  else   (((const ::std::vector<TinyEvent>*)o)->size)();
}

static  void method_6159( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TinyEvent>*)o)->max_size)());
  else   (((const ::std::vector<TinyEvent>*)o)->max_size)();
}

static  void method_6160( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<TinyEvent>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<TinyEvent>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::TinyEvent*)arg[1]);
  }
}

static  void method_6161( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<TinyEvent>*)o)->capacity)());
  else   (((const ::std::vector<TinyEvent>*)o)->capacity)();
}

static  void method_6162( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<TinyEvent>*)o)->empty)());
  else   (((const ::std::vector<TinyEvent>*)o)->empty)();
}

static  void method_6163( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TinyEvent>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_6164( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TinyEvent>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TinyEvent>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_6165( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TinyEvent>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TinyEvent>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_6167( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TinyEvent>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<TinyEvent>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6168( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TinyEvent>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<TinyEvent>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_6169( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TinyEvent>*)o)->front)();
  else   (((::std::vector<TinyEvent>*)o)->front)();
}

static  void method_6170( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TinyEvent>*)o)->front)();
  else   (((const ::std::vector<TinyEvent>*)o)->front)();
}

static  void method_6171( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<TinyEvent>*)o)->back)();
  else   (((::std::vector<TinyEvent>*)o)->back)();
}

static  void method_6172( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<TinyEvent>*)o)->back)();
  else   (((const ::std::vector<TinyEvent>*)o)->back)();
}

static  void method_6173( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<TinyEvent>*)o)->data)());
  else   (((::std::vector<TinyEvent>*)o)->data)();
}

static  void method_6174( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<TinyEvent>*)o)->data)());
  else   (((const ::std::vector<TinyEvent>*)o)->data)();
}

static  void method_6175( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TinyEvent>*)o)->push_back)(*(const ::TinyEvent*)arg[0]);
}

static  void method_6176( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TinyEvent>*)o)->pop_back)();
}

static  void method_6177( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >)((((::std::vector<TinyEvent>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >*)arg[0],
    *(const ::TinyEvent*)arg[1]));
  else   (((::std::vector<TinyEvent>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >*)arg[0],
    *(const ::TinyEvent*)arg[1]);
}

static  void method_6178( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TinyEvent>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::TinyEvent*)arg[2]);
}

static  void method_6179( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >)((((::std::vector<TinyEvent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >*)arg[0]));
  else   (((::std::vector<TinyEvent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >*)arg[0]);
}

static  void method_6180( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >)((((::std::vector<TinyEvent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >*)arg[1]));
  else   (((::std::vector<TinyEvent>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<TinyEvent*,std::vector<TinyEvent> >*)arg[1]);
}

static  void method_6181( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<TinyEvent>*)o)->swap)(*(::std::vector<TinyEvent>*)arg[0]);
}

static  void method_6182( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<TinyEvent>*)o)->clear)();
}

static void method_newdel_1352( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<TinyEvent> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<TinyEvent> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<TinyEvent> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<TinyEvent> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<TinyEvent> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x6( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<TinyEvent,std::allocator<TinyEvent> >")), ::Reflex::BaseOffset< ::std::vector<TinyEvent>,::std::_Vector_base<TinyEvent,std::allocator<TinyEvent> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x7( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<TinyEvent> >::Generate();
  else ::Reflex::Proxy< ::std::vector<TinyEvent> >::Generate();
}

//------Dictionary for class vector<TinyEvent,std::allocator<TinyEvent> > -------------------------------
void __std__vector_TinyEvent__db_datamem(Reflex::Class*);
void __std__vector_TinyEvent__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_TinyEvent__datamem_bld(&__std__vector_TinyEvent__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_TinyEvent__funcmem_bld(&__std__vector_TinyEvent__db_funcmem);
void __std__vector_TinyEvent__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<TinyEvent>"), typeid(::std::vector<TinyEvent>), sizeof(::std::vector<TinyEvent>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("persistent"), "false")
  .AddBase(type_2218, ::Reflex::BaseOffset< ::std::vector<TinyEvent>, ::std::_Vector_base<TinyEvent,std::allocator<TinyEvent> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_61, Reflex::Literal("std::vector<TinyEvent>::_Alloc_value_type"))
  .AddTypedef(type_2218, Reflex::Literal("std::vector<TinyEvent>::_Base"))
  .AddTypedef(type_3282, Reflex::Literal("std::vector<TinyEvent>::_Tp_alloc_type"))
  .AddTypedef(type_61, Reflex::Literal("std::vector<TinyEvent>::value_type"))
  .AddTypedef(type_6128, Reflex::Literal("std::vector<TinyEvent>::pointer"))
  .AddTypedef(type_6130, Reflex::Literal("std::vector<TinyEvent>::const_pointer"))
  .AddTypedef(type_6132, Reflex::Literal("std::vector<TinyEvent>::reference"))
  .AddTypedef(type_6134, Reflex::Literal("std::vector<TinyEvent>::const_reference"))
  .AddTypedef(type_5483, Reflex::Literal("std::vector<TinyEvent>::iterator"))
  .AddTypedef(type_5484, Reflex::Literal("std::vector<TinyEvent>::const_iterator"))
  .AddTypedef(type_3563, Reflex::Literal("std::vector<TinyEvent>::const_reverse_iterator"))
  .AddTypedef(type_3564, Reflex::Literal("std::vector<TinyEvent>::reverse_iterator"))
  .AddTypedef(type_2839, Reflex::Literal("std::vector<TinyEvent>::size_type"))
  .AddTypedef(type_3017, Reflex::Literal("std::vector<TinyEvent>::difference_type"))
  .AddTypedef(type_3282, Reflex::Literal("std::vector<TinyEvent>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_6143, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28870), Reflex::Literal("vector"), constructor_6144, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2839, type_6134, type_28870), Reflex::Literal("vector"), constructor_6145, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28871), Reflex::Literal("vector"), constructor_6146, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_6147, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1352, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x6, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x7, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_TinyEvent__funcmem_bld);
}

//------Delayed data member builder for class vector<TinyEvent,std::allocator<TinyEvent> > -------------------
void __std__vector_TinyEvent__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<TinyEvent,std::allocator<TinyEvent> > -------------------
void __std__vector_TinyEvent__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28872, type_28871), Reflex::Literal("operator="), operator_6148, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_2839, type_6134), Reflex::Literal("assign"), method_6149, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5483), Reflex::Literal("begin"), method_6150, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5484), Reflex::Literal("begin"), method_6151, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5483), Reflex::Literal("end"), method_6152, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5484), Reflex::Literal("end"), method_6153, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2839), Reflex::Literal("size"), method_6158, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2839), Reflex::Literal("max_size"), method_6159, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_2839, type_61), Reflex::Literal("resize"), method_6160, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2839), Reflex::Literal("capacity"), method_6161, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3664), Reflex::Literal("empty"), method_6162, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_2839), Reflex::Literal("reserve"), method_6163, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6132, type_2839), Reflex::Literal("operator[]"), operator_6164, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134, type_2839), Reflex::Literal("operator[]"), operator_6165, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6132, type_2839), Reflex::Literal("at"), method_6167, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134, type_2839), Reflex::Literal("at"), method_6168, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6132), Reflex::Literal("front"), method_6169, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("front"), method_6170, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6132), Reflex::Literal("back"), method_6171, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6134), Reflex::Literal("back"), method_6172, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6128), Reflex::Literal("data"), method_6173, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_6130), Reflex::Literal("data"), method_6174, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_6134), Reflex::Literal("push_back"), method_6175, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347), Reflex::Literal("pop_back"), method_6176, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5483, type_5483, type_6134), Reflex::Literal("insert"), method_6177, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_5483, type_2839, type_6134), Reflex::Literal("insert"), method_6178, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5483, type_5483), Reflex::Literal("erase"), method_6179, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5483, type_5483, type_5483), Reflex::Literal("erase"), method_6180, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_28872), Reflex::Literal("swap"), method_6181, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347), Reflex::Literal("clear"), method_6182, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<APVCyclePhaseCollection> -------------------------------
static void constructor_23651( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<APVCyclePhaseCollection>();
  else ::new(mem) ::edm::Wrapper<APVCyclePhaseCollection>();
}

static void constructor_23652( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<APVCyclePhaseCollection>(*(::std::auto_ptr<APVCyclePhaseCollection>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<APVCyclePhaseCollection>(*(::std::auto_ptr<APVCyclePhaseCollection>*)arg[0]);
}

static void destructor_23653(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<APVCyclePhaseCollection>*)o)->::edm::Wrapper<APVCyclePhaseCollection>::~Wrapper)();
}
static  void method_23654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->product)());
  else   (((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->product)();
}

static  void operator_23655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->operator->)());
  else   (((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->operator->)();
}

static  void method_23656( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<APVCyclePhaseCollection>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<APVCyclePhaseCollection>*)o)->productTypeInfo)();
}

static  void method_23657( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<APVCyclePhaseCollection>*)o)->typeInfo)();
  else   (((::edm::Wrapper<APVCyclePhaseCollection>*)o)->typeInfo)();
}

static void constructor_23658( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<APVCyclePhaseCollection>((::APVCyclePhaseCollection*)arg[0]);
  else ::new(mem) ::edm::Wrapper<APVCyclePhaseCollection>((::APVCyclePhaseCollection*)arg[0]);
}

static  void method_23659( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<APVCyclePhaseCollection>*)o)->getInterface)());
  else   (((::edm::Wrapper<APVCyclePhaseCollection>*)o)->getInterface)();
}

static  void method_23660( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23661( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23662( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23663( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->dynamicTypeInfo)();
}

static  void method_23664( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->isPresent)();
}

static  void method_23665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<APVCyclePhaseCollection>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4565( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<APVCyclePhaseCollection> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<APVCyclePhaseCollection> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<APVCyclePhaseCollection> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<APVCyclePhaseCollection> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<APVCyclePhaseCollection> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<APVCyclePhaseCollection> -------------------------------
void __edm__Wrapper_APVCyclePhaseCollection__db_datamem(Reflex::Class*);
void __edm__Wrapper_APVCyclePhaseCollection__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_APVCyclePhaseCollection__datamem_bld(&__edm__Wrapper_APVCyclePhaseCollection__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_APVCyclePhaseCollection__funcmem_bld(&__edm__Wrapper_APVCyclePhaseCollection__db_funcmem);
void __edm__Wrapper_APVCyclePhaseCollection__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<APVCyclePhaseCollection>"), typeid(::edm::Wrapper<APVCyclePhaseCollection>), sizeof(::edm::Wrapper<APVCyclePhaseCollection>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("persistent"), "false")
  .AddTypedef(type_288, Reflex::Literal("edm::Wrapper<APVCyclePhaseCollection>::value_type"))
  .AddTypedef(type_288, Reflex::Literal("edm::Wrapper<APVCyclePhaseCollection>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23651, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2527), Reflex::Literal("Wrapper"), constructor_23652, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23653, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_37550), Reflex::Literal("Wrapper"), constructor_23658, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4565, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_APVCyclePhaseCollection__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_APVCyclePhaseCollection__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<APVCyclePhaseCollection> -------------------
void __edm__Wrapper_APVCyclePhaseCollection__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3664, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_APVCyclePhaseCollection_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_288, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_APVCyclePhaseCollection_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<APVCyclePhaseCollection> -------------------
void __edm__Wrapper_APVCyclePhaseCollection__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37549), Reflex::Literal("product"), method_23654, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37549), Reflex::Literal("operator->"), operator_23655, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4502), Reflex::Literal("productTypeInfo"), method_23656, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4502), Reflex::Literal("typeInfo"), method_23657, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37551), Reflex::Literal("getInterface"), method_23659, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_19815, type_32307, type_33253), Reflex::Literal("fillView"), method_23660, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_4502, type_306, type_7791), Reflex::Literal("setPtr"), method_23661, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_4502, type_32308, type_32307), Reflex::Literal("fillPtrVector"), method_23662, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4502), Reflex::Literal("dynamicTypeInfo"), method_23663, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3664), Reflex::Literal("isPresent"), method_23664, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4502), Reflex::Literal("dynamicTypeInfo_"), method_23665, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<EventWithHistory> -------------------------------
static void constructor_23672( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<EventWithHistory>();
  else ::new(mem) ::edm::Wrapper<EventWithHistory>();
}

static void constructor_23673( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<EventWithHistory>(*(::std::auto_ptr<EventWithHistory>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<EventWithHistory>(*(::std::auto_ptr<EventWithHistory>*)arg[0]);
}

static void destructor_23674(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<EventWithHistory>*)o)->::edm::Wrapper<EventWithHistory>::~Wrapper)();
}
static  void method_23675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<EventWithHistory>*)o)->product)());
  else   (((const ::edm::Wrapper<EventWithHistory>*)o)->product)();
}

static  void operator_23676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<EventWithHistory>*)o)->operator->)());
  else   (((const ::edm::Wrapper<EventWithHistory>*)o)->operator->)();
}

static  void method_23677( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<EventWithHistory>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<EventWithHistory>*)o)->productTypeInfo)();
}

static  void method_23678( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<EventWithHistory>*)o)->typeInfo)();
  else   (((::edm::Wrapper<EventWithHistory>*)o)->typeInfo)();
}

static void constructor_23679( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<EventWithHistory>((::EventWithHistory*)arg[0]);
  else ::new(mem) ::edm::Wrapper<EventWithHistory>((::EventWithHistory*)arg[0]);
}

static  void method_23680( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<EventWithHistory>*)o)->getInterface)());
  else   (((::edm::Wrapper<EventWithHistory>*)o)->getInterface)();
}

static  void method_23681( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<EventWithHistory>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23682( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<EventWithHistory>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23683( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<EventWithHistory>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23684( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<EventWithHistory>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<EventWithHistory>*)o)->dynamicTypeInfo)();
}

static  void method_23685( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<EventWithHistory>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<EventWithHistory>*)o)->isPresent)();
}

static  void method_23686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<EventWithHistory>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<EventWithHistory>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4566( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<EventWithHistory> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<EventWithHistory> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<EventWithHistory> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<EventWithHistory> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<EventWithHistory> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<EventWithHistory> -------------------------------
void __edm__Wrapper_EventWithHistory__db_datamem(Reflex::Class*);
void __edm__Wrapper_EventWithHistory__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_EventWithHistory__datamem_bld(&__edm__Wrapper_EventWithHistory__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_EventWithHistory__funcmem_bld(&__edm__Wrapper_EventWithHistory__db_funcmem);
void __edm__Wrapper_EventWithHistory__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<EventWithHistory>"), typeid(::edm::Wrapper<EventWithHistory>), sizeof(::edm::Wrapper<EventWithHistory>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("persistent"), "false")
  .AddTypedef(type_321, Reflex::Literal("edm::Wrapper<EventWithHistory>::value_type"))
  .AddTypedef(type_321, Reflex::Literal("edm::Wrapper<EventWithHistory>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23672, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2528), Reflex::Literal("Wrapper"), constructor_23673, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23674, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_37555), Reflex::Literal("Wrapper"), constructor_23679, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4566, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_EventWithHistory__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_EventWithHistory__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<EventWithHistory> -------------------
void __edm__Wrapper_EventWithHistory__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3664, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_EventWithHistory_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_321, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_EventWithHistory_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<EventWithHistory> -------------------
void __edm__Wrapper_EventWithHistory__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37554), Reflex::Literal("product"), method_23675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37554), Reflex::Literal("operator->"), operator_23676, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4502), Reflex::Literal("productTypeInfo"), method_23677, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4502), Reflex::Literal("typeInfo"), method_23678, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37556), Reflex::Literal("getInterface"), method_23680, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_19815, type_32307, type_33253), Reflex::Literal("fillView"), method_23681, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_4502, type_306, type_7791), Reflex::Literal("setPtr"), method_23682, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_4502, type_32308, type_32307), Reflex::Literal("fillPtrVector"), method_23683, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4502), Reflex::Literal("dynamicTypeInfo"), method_23684, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3664), Reflex::Literal("isPresent"), method_23685, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4502), Reflex::Literal("dynamicTypeInfo_"), method_23686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<TinyEvent, std::allocator<TinyEvent> > > -------------------------------
static void constructor_23693( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<TinyEvent> >();
  else ::new(mem) ::edm::Wrapper<std::vector<TinyEvent> >();
}

static void constructor_23694( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<TinyEvent> >(*(::std::auto_ptr<std::vector<TinyEvent> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<TinyEvent> >(*(::std::auto_ptr<std::vector<TinyEvent> >*)arg[0]);
}

static void destructor_23695(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<TinyEvent> >*)o)->::edm::Wrapper<std::vector<TinyEvent> >::~Wrapper)();
}
static  void method_23696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->product)();
}

static  void operator_23697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->operator->)();
}

static  void method_23698( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<TinyEvent> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<TinyEvent> >*)o)->productTypeInfo)();
}

static  void method_23699( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<TinyEvent> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<TinyEvent> >*)o)->typeInfo)();
}

static void constructor_23700( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<TinyEvent> >((::std::vector<TinyEvent>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<TinyEvent> >((::std::vector<TinyEvent>*)arg[0]);
}

static  void method_23701( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<TinyEvent> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<TinyEvent> >*)o)->getInterface)();
}

static  void method_23702( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_23703( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_23704( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_23705( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->dynamicTypeInfo)();
}

static  void method_23706( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->isPresent)();
}

static  void method_23707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<TinyEvent> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4567( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TinyEvent> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TinyEvent> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TinyEvent> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TinyEvent> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<TinyEvent> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<TinyEvent, std::allocator<TinyEvent> > > -------------------------------
void __edm__Wrapper_std__vector_TinyEvent_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_TinyEvent_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_TinyEvent_s__datamem_bld(&__edm__Wrapper_std__vector_TinyEvent_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_TinyEvent_s__funcmem_bld(&__edm__Wrapper_std__vector_TinyEvent_s__db_funcmem);
void __edm__Wrapper_std__vector_TinyEvent_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<TinyEvent> >"), typeid(::edm::Wrapper<std::vector<TinyEvent> >), sizeof(::edm::Wrapper<std::vector<TinyEvent> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("persistent"), "false")
  .AddTypedef(type_1352, Reflex::Literal("edm::Wrapper<std::vector<TinyEvent> >::value_type"))
  .AddTypedef(type_1352, Reflex::Literal("edm::Wrapper<std::vector<TinyEvent> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_23693, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2529), Reflex::Literal("Wrapper"), constructor_23694, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_23695, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_37560), Reflex::Literal("Wrapper"), constructor_23700, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4567, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_TinyEvent_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_TinyEvent_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<TinyEvent, std::allocator<TinyEvent> > > -------------------
void __edm__Wrapper_std__vector_TinyEvent_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_3664, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_TinyEvent_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_1352, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_TinyEvent_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<TinyEvent, std::allocator<TinyEvent> > > -------------------
void __edm__Wrapper_std__vector_TinyEvent_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37559), Reflex::Literal("product"), method_23696, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37559), Reflex::Literal("operator->"), operator_23697, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4502), Reflex::Literal("productTypeInfo"), method_23698, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4502), Reflex::Literal("typeInfo"), method_23699, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_37561), Reflex::Literal("getInterface"), method_23701, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_19815, type_32307, type_33253), Reflex::Literal("fillView"), method_23702, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_4502, type_306, type_7791), Reflex::Literal("setPtr"), method_23703, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_4502, type_32308, type_32307), Reflex::Literal("fillPtrVector"), method_23704, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4502), Reflex::Literal("dynamicTypeInfo"), method_23705, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_3664), Reflex::Literal("isPresent"), method_23706, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4502), Reflex::Literal("dynamicTypeInfo_"), method_23707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> > -------------------------------
static void destructor_3701(void*, void * o, const std::vector<void*>&, void *) {
(((::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >*)o)->::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >::~SingleMultiplicity)();
}
static  void operator_3702( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >*)o)->operator=)(*(const ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >*)arg[0]);
  else   (((::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >*)o)->operator=)(*(const ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >*)arg[0]);
}

static void constructor_3703( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >(*(const ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >*)arg[0]);
  else ::new(mem) ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >(*(const ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >*)arg[0]);
}

static void constructor_3704( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >();
  else ::new(mem) ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >();
}

static void constructor_3705( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >(*(const ::edm::ParameterSet*)arg[0]);
  else ::new(mem) ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >(*(const ::edm::ParameterSet*)arg[0]);
}

static  void method_3706( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >*)o)->getEvent)(*(const ::edm::Event*)arg[0],
    *(const ::edm::EventSetup*)arg[1]);
}

static  void method_3707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >*)o)->mult)());
  else   (((const ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >*)o)->mult)();
}

static void method_newdel_46( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> > -------------------------------
void __SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__db_datamem(Reflex::Class*);
void __SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__datamem_bld(&__SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__funcmem_bld(&__SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__db_funcmem);
void __SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >"), typeid(::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >), sizeof(::SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("persistent"), "false")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SingleMultiplicity"), destructor_3701, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_19751, type_19752), Reflex::Literal("operator="), operator_3702, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_19752), Reflex::Literal("SingleMultiplicity"), constructor_3703, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SingleMultiplicity"), constructor_3704, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13536), Reflex::Literal("SingleMultiplicity"), constructor_3705, 0, "iConfig", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_46, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__funcmem_bld);
}

//------Delayed data member builder for class SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> > -------------------
void __SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4537, Reflex::Literal("m_collection"), OffsetOf(__shadow__::__SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s_, m_collection), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("m_modthr"), OffsetOf(__shadow__::__SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s_, m_modthr), ::Reflex::PRIVATE)
  .AddDataMember(type_3664, Reflex::Literal("m_useQuality"), OffsetOf(__shadow__::__SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s_, m_useQuality), ::Reflex::PRIVATE)
  .AddDataMember(type_2225, Reflex::Literal("m_qualityLabel"), OffsetOf(__shadow__::__SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s_, m_qualityLabel), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("m_mult"), OffsetOf(__shadow__::__SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s_, m_mult), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> > -------------------
void __SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_19753, type_19754), Reflex::Literal("getEvent"), method_3706, 0, "iEvent;iSetup", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("mult"), method_3707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > -------------------------------
static void destructor_4953(void*, void * o, const std::vector<void*>&, void *) {
(((::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >*)o)->::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >::~SingleMultiplicity)();
}
static  void operator_4954( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >*)o)->operator=)(*(const ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >*)arg[0]);
  else   (((::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >*)o)->operator=)(*(const ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >*)arg[0]);
}

static void constructor_4955( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >(*(const ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >*)arg[0]);
  else ::new(mem) ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >(*(const ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >*)arg[0]);
}

static void constructor_4956( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >();
  else ::new(mem) ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >();
}

static void constructor_4957( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >(*(const ::edm::ParameterSet*)arg[0]);
  else ::new(mem) ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >(*(const ::edm::ParameterSet*)arg[0]);
}

static  void method_4958( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >*)o)->getEvent)(*(const ::edm::Event*)arg[0],
    *(const ::edm::EventSetup*)arg[1]);
}

static  void method_4959( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >*)o)->mult)());
  else   (((const ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >*)o)->mult)();
}

static void method_newdel_494( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > -------------------------------
void __SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s__db_datamem(Reflex::Class*);
void __SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s__datamem_bld(&__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s__db_datamem);
Reflex::GenreflexMemberBuilder __SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s__funcmem_bld(&__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s__db_funcmem);
void __SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >"), typeid(::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >), sizeof(::SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("persistent"), "false")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SingleMultiplicity"), destructor_4953, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25318, type_25319), Reflex::Literal("operator="), operator_4954, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25319), Reflex::Literal("SingleMultiplicity"), constructor_4955, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SingleMultiplicity"), constructor_4956, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13536), Reflex::Literal("SingleMultiplicity"), constructor_4957, 0, "iConfig", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_494, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s__funcmem_bld);
}

//------Delayed data member builder for class SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > -------------------
void __SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4537, Reflex::Literal("m_collection"), OffsetOf(__shadow__::__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_, m_collection), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("m_modthr"), OffsetOf(__shadow__::__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_, m_modthr), ::Reflex::PRIVATE)
  .AddDataMember(type_3664, Reflex::Literal("m_useQuality"), OffsetOf(__shadow__::__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_, m_useQuality), ::Reflex::PRIVATE)
  .AddDataMember(type_2225, Reflex::Literal("m_qualityLabel"), OffsetOf(__shadow__::__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_, m_qualityLabel), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("m_mult"), OffsetOf(__shadow__::__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_, m_mult), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > -------------------
void __SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_19753, type_19754), Reflex::Literal("getEvent"), method_4958, 0, "iEvent;iSetup", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("mult"), method_4959, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class SingleMultiplicity<edm::DetSetVector<SiStripDigi> > -------------------------------
static void destructor_6325(void*, void * o, const std::vector<void*>&, void *) {
(((::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >*)o)->::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >::~SingleMultiplicity)();
}
static  void operator_6326( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >*)o)->operator=)(*(const ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >*)arg[0]);
  else   (((::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >*)o)->operator=)(*(const ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >*)arg[0]);
}

static void constructor_6327( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >(*(const ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >*)arg[0]);
  else ::new(mem) ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >(*(const ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >*)arg[0]);
}

static void constructor_6328( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >();
  else ::new(mem) ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >();
}

static void constructor_6329( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >(*(const ::edm::ParameterSet*)arg[0]);
  else ::new(mem) ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >(*(const ::edm::ParameterSet*)arg[0]);
}

static  void method_6330( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >*)o)->getEvent)(*(const ::edm::Event*)arg[0],
    *(const ::edm::EventSetup*)arg[1]);
}

static  void method_6331( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >*)o)->mult)());
  else   (((const ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >*)o)->mult)();
}

static void method_newdel_1444( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::SingleMultiplicity<edm::DetSetVector<SiStripDigi> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class SingleMultiplicity<edm::DetSetVector<SiStripDigi> > -------------------------------
void __SingleMultiplicity_edm__DetSetVector_SiStripDigi_s__db_datamem(Reflex::Class*);
void __SingleMultiplicity_edm__DetSetVector_SiStripDigi_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __SingleMultiplicity_edm__DetSetVector_SiStripDigi_s__datamem_bld(&__SingleMultiplicity_edm__DetSetVector_SiStripDigi_s__db_datamem);
Reflex::GenreflexMemberBuilder __SingleMultiplicity_edm__DetSetVector_SiStripDigi_s__funcmem_bld(&__SingleMultiplicity_edm__DetSetVector_SiStripDigi_s__db_funcmem);
void __SingleMultiplicity_edm__DetSetVector_SiStripDigi_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("SingleMultiplicity<edm::DetSetVector<SiStripDigi> >"), typeid(::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >), sizeof(::SingleMultiplicity<edm::DetSetVector<SiStripDigi> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("persistent"), "false")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~SingleMultiplicity"), destructor_6325, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_30004, type_30005), Reflex::Literal("operator="), operator_6326, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_30005), Reflex::Literal("SingleMultiplicity"), constructor_6327, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("SingleMultiplicity"), constructor_6328, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13536), Reflex::Literal("SingleMultiplicity"), constructor_6329, 0, "iConfig", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_1444, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__SingleMultiplicity_edm__DetSetVector_SiStripDigi_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__SingleMultiplicity_edm__DetSetVector_SiStripDigi_s__funcmem_bld);
}

//------Delayed data member builder for class SingleMultiplicity<edm::DetSetVector<SiStripDigi> > -------------------
void __SingleMultiplicity_edm__DetSetVector_SiStripDigi_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_4537, Reflex::Literal("m_collection"), OffsetOf(__shadow__::__SingleMultiplicity_edm__DetSetVector_SiStripDigi_s_, m_collection), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("m_modthr"), OffsetOf(__shadow__::__SingleMultiplicity_edm__DetSetVector_SiStripDigi_s_, m_modthr), ::Reflex::PRIVATE)
  .AddDataMember(type_3664, Reflex::Literal("m_useQuality"), OffsetOf(__shadow__::__SingleMultiplicity_edm__DetSetVector_SiStripDigi_s_, m_useQuality), ::Reflex::PRIVATE)
  .AddDataMember(type_2225, Reflex::Literal("m_qualityLabel"), OffsetOf(__shadow__::__SingleMultiplicity_edm__DetSetVector_SiStripDigi_s_, m_qualityLabel), ::Reflex::PRIVATE)
  .AddDataMember(type_72, Reflex::Literal("m_mult"), OffsetOf(__shadow__::__SingleMultiplicity_edm__DetSetVector_SiStripDigi_s_, m_mult), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class SingleMultiplicity<edm::DetSetVector<SiStripDigi> > -------------------
void __SingleMultiplicity_edm__DetSetVector_SiStripDigi_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_19753, type_19754), Reflex::Literal("getEvent"), method_6330, 0, "iEvent;iSetup", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("mult"), method_6331, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity> -------------------------------
static void destructor_5948(void*, void * o, const std::vector<void*>&, void *) {
(((::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>*)o)->::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>::~MultiplicityPair)();
}
static  void operator_5949( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>*)o)->operator=)(*(const ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>*)arg[0]);
  else   (((::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>*)o)->operator=)(*(const ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>*)arg[0]);
}

static void constructor_5950( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>(*(const ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>*)arg[0]);
  else ::new(mem) ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>(*(const ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>*)arg[0]);
}

static void constructor_5951( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>();
  else ::new(mem) ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>();
}

static void constructor_5952( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>(*(const ::edm::ParameterSet*)arg[0]);
  else ::new(mem) ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>(*(const ::edm::ParameterSet*)arg[0]);
}

static  void method_5953( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>*)o)->getEvent)(*(const ::edm::Event*)arg[0],
    *(const ::edm::EventSetup*)arg[1]);
}

static  void method_5954( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>*)o)->mult1)());
  else   (((const ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>*)o)->mult1)();
}

static  void method_5955( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>*)o)->mult2)());
  else   (((const ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>*)o)->mult2)();
}

static void method_newdel_981( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity> -------------------------------
void __MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity__db_datamem(Reflex::Class*);
void __MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity__datamem_bld(&__MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity__db_datamem);
Reflex::GenreflexMemberBuilder __MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity__funcmem_bld(&__MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity__db_funcmem);
void __MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>"), typeid(::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>), sizeof(::MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("persistent"), "false")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MultiplicityPair"), destructor_5948, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28775, type_28776), Reflex::Literal("operator="), operator_5949, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28776), Reflex::Literal("MultiplicityPair"), constructor_5950, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MultiplicityPair"), constructor_5951, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13536), Reflex::Literal("MultiplicityPair"), constructor_5952, 0, "iConfig", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_981, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity__funcmem_bld);
}

//------Delayed data member builder for class MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity> -------------------
void __MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1290, Reflex::Literal("m_multiplicity1"), OffsetOf(__shadow__::__MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity_, m_multiplicity1), ::Reflex::PRIVATE)
  .AddDataMember(type_1290, Reflex::Literal("m_multiplicity2"), OffsetOf(__shadow__::__MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity_, m_multiplicity2), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity> -------------------
void __MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_19753, type_19754), Reflex::Literal("getEvent"), method_5953, 0, "iEvent;iSetup", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("mult1"), method_5954, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("mult2"), method_5955, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > > -------------------------------
static void destructor_5958(void*, void * o, const std::vector<void*>&, void *) {
(((::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >*)o)->::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >::~MultiplicityPair)();
}
static  void operator_5959( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >*)o)->operator=)(*(const ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >*)arg[0]);
  else   (((::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >*)o)->operator=)(*(const ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >*)arg[0]);
}

static void constructor_5960( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >(*(const ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >*)arg[0]);
  else ::new(mem) ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >(*(const ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >*)arg[0]);
}

static void constructor_5961( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >();
  else ::new(mem) ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >();
}

static void constructor_5962( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >(*(const ::edm::ParameterSet*)arg[0]);
  else ::new(mem) ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >(*(const ::edm::ParameterSet*)arg[0]);
}

static  void method_5963( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >*)o)->getEvent)(*(const ::edm::Event*)arg[0],
    *(const ::edm::EventSetup*)arg[1]);
}

static  void method_5964( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >*)o)->mult1)());
  else   (((const ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >*)o)->mult1)();
}

static  void method_5965( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >*)o)->mult2)());
  else   (((const ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >*)o)->mult2)();
}

static void method_newdel_982( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > > -------------------------------
void __MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s__db_datamem(Reflex::Class*);
void __MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s__datamem_bld(&__MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s__db_datamem);
Reflex::GenreflexMemberBuilder __MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s__funcmem_bld(&__MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s__db_funcmem);
void __MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >"), typeid(::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >), sizeof(::MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("persistent"), "false")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~MultiplicityPair"), destructor_5958, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_28777, type_28778), Reflex::Literal("operator="), operator_5959, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_28778), Reflex::Literal("MultiplicityPair"), constructor_5960, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("MultiplicityPair"), constructor_5961, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_13536), Reflex::Literal("MultiplicityPair"), constructor_5962, 0, "iConfig", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_982, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s__funcmem_bld);
}

//------Delayed data member builder for class MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > > -------------------
void __MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_46, Reflex::Literal("m_multiplicity1"), OffsetOf(__shadow__::__MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s_, m_multiplicity1), ::Reflex::PRIVATE)
  .AddDataMember(type_494, Reflex::Literal("m_multiplicity2"), OffsetOf(__shadow__::__MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s_, m_multiplicity2), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > > -------------------
void __MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_347, type_19753, type_19754), Reflex::Literal("getEvent"), method_5963, 0, "iEvent;iSetup", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("mult1"), method_5964, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_72), Reflex::Literal("mult2"), method_5965, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __TinyEvent_dict(); 
      __APVCyclePhaseCollection_dict(); 
      __EventWithHistory_dict(); 
      __ClusterSummarySingleMultiplicity_dict(); 
      __std__vector_TinyEvent__dict(); 
      __edm__Wrapper_APVCyclePhaseCollection__dict(); 
      __edm__Wrapper_EventWithHistory__dict(); 
      __edm__Wrapper_std__vector_TinyEvent_s__dict(); 
      __SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__dict(); 
      __SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s__dict(); 
      __SingleMultiplicity_edm__DetSetVector_SiStripDigi_s__dict(); 
      __MultiplicityPair_ClusterSummarySingleMultiplicity_ClusterSummarySingleMultiplicity__dict(); 
      __MultiplicityPair_SingleMultiplicity_edmNew__DetSetVector_SiPixelCluster_s__SingleMultiplicity_edmNew__DetSetVector_SiStripCluster_s_s__dict(); 
    }
    ~Dictionaries() {
      type_61.Unload(); // class TinyEvent 
      type_288.Unload(); // class APVCyclePhaseCollection 
      type_321.Unload(); // class EventWithHistory 
      type_1290.Unload(); // class ClusterSummarySingleMultiplicity 
      type_1352.Unload(); // class std::vector<TinyEvent> 
      type_4565.Unload(); // class edm::Wrapper<APVCyclePhaseCollection> 
      type_4566.Unload(); // class edm::Wrapper<EventWithHistory> 
      type_4567.Unload(); // class edm::Wrapper<std::vector<TinyEvent> > 
      type_46.Unload(); // class SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> > 
      type_494.Unload(); // class SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > 
      type_1444.Unload(); // class SingleMultiplicity<edm::DetSetVector<SiStripDigi> > 
      type_981.Unload(); // class MultiplicityPair<ClusterSummarySingleMultiplicity,ClusterSummarySingleMultiplicity> 
      type_982.Unload(); // class MultiplicityPair<SingleMultiplicity<edmNew::DetSetVector<SiPixelCluster> >,SingleMultiplicity<edmNew::DetSetVector<SiStripCluster> > > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
